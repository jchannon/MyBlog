<!DOCTYPE HTML>

<html lang='en'>
	<head>
		<title>Introducing Negotiator  - a GoLang content negotiation library &middot; Jonathan Channon Blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		
		
		
		<link rel="stylesheet" href="/assets/css/main.min.css">
		
		
		
		<noscript><link rel="stylesheet" href='/assets/css/noscript.css' /></noscript>
	</head>

	<body lang='en' class="is-preload">

		
			<div id="wrapper">

                
<header id="header">
    <a href='/' class="logo">Blog</a>
</header>

                

<nav id="nav">
    <ul class="links">
        <li class="active"><a href='/'>Blog</a></li>
        
        
    </ul>
    
    <ul class="icons">
        
        <li><a href="https://twitter.com/jchannon" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
        
        
        <li><a href="https://github.com/jchannon" class="icon fa-github"><span class="label">GitHub</span></a></li>
        
        
        
        
        <li><a href="https://www.linkedin.com/in/jonathanchannon/" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li>
        
        
        
        
        
    </ul>
    
</nav>


				
					<div id="main">

						
                        <section class="post">
                            <header class="major">
                                
                                <span class="date">Mon, Nov 16, 2015</span>
                                
                                <h1>Introducing Negotiator  - a GoLang content negotiation library</h1>
                                <p></p>
                            </header>
                            
                            <p>In my continued experience learning GoLang I started looking at how to best use it when dealing with HTTP.  The idiomatic way to use GoLang and HTTP is to use the standard library which keeps things minimal but there are a few features missing.  The first thing is a router.  OOTB GoLang doesn&rsquo;t have a router and the majority seem to suggest using a package called Mux from Gorilla Toolkit, a set of libraries that aims to improve the standard library from Go.  After having a play with it I didn&rsquo;t really warm to it so spent some time looking into the alternatives (and there are plenty!) and eventually decided upon <a href="https://goji.io">Goji</a></p>
<p>Once I had started using Goji I then wanted to handle content negotiation in my HTTP handler.  As I said earlier GoLang is minimal in its offerings OOTB and this is a good thing.  Just for the record there are a few frameworks out there if you want/need and all encompassing framework such as Martini, Revel and Echo.  These tend to bend the idioms  of GoLang a bit and even the author of Martini blogged on this fact due to feedback from the community that although its capabilities are great they aren&rsquo;t idiomatic Go.</p>
<h3 id="introducing-negotiator">Introducing Negotiator</h3>
<p>After realising that Goji didn&rsquo;t have content negotiation seeing as its just a router (although there are Goji compatible middleware, which in turn are standard library compatible) I started playing on how to implement conneg.</p>
<p>My first attempt was a piece of middleware that allowed the request to go to Goji and then on the way back up it would interrogate the context for a model which the HTTP handler would have inserted, it would then interrogate the Accept header obviously and then write out the JSON/XML to the response.</p>
<pre><code>//***** HTTP Handler *****

func HelloWorldHTTPHandler(ctx web.C, w http.ResponseWriter, req *http.Request) {
    user := &amp;User{&quot;Joe&quot;,&quot;Bloggs&quot;}

    ctx.Env[&quot;model&quot;] = user
}

//*****First stab at content negotiation midleware *****

package conneg

import (
&quot;encoding/json&quot;
&quot;encoding/xml&quot;
&quot;net/http&quot;

&quot;github.com/zenazn/goji/web&quot;
)

func Conneg(c *web.C, h http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, r *http.Request) {

        h.ServeHTTP(w, r)

        accept := r.Header.Get(&quot;Accept&quot;)
        if model := c.Env[&quot;model&quot;]; model != nil {

            switch accept {
            case &quot;application/json&quot;:

                w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)

                js, err := json.Marshal(model)

                if err != nil {
                    http.Error(w, err.Error(), http.StatusInternalServerError)
                    return
                }
                if statuscode := c.Env[&quot;statuscode&quot;]; statuscode != nil {
                    w.WriteHeader(statuscode.(int))
                }
                w.Write(js)

            case &quot;application/xml&quot;:
                x, err := xml.MarshalIndent(model, &quot;&quot;, &quot;  &quot;)
                if err != nil {
                    http.Error(w, err.Error(), http.StatusInternalServerError)
                    return
                }

                w.Header().Set(&quot;Content-Type&quot;, &quot;application/xml&quot;)
                w.Write(x)
            }
        }

    }
    return http.HandlerFunc(fn)
}
</code></pre>
<p>As you can see its pretty rudimentary but does the job but if I developed multiple web applications I would have to copy and paste this into every app that I wrote.  I would also have to add to the switch statement for every media type I wanted to handle.</p>
<p>I wanted to write a library that I could reference for every web application, separate out each response processor instead of having a switch statement, have the ability to write new response processors that conformed to an interface plus get more experience with Go and of course make it OSS.</p>
<p>To cut a long story short if you install a reference to <code>github.com/jchannon/negotiator</code> you can how have a HTTP handler like so:</p>
<pre><code>func getUser(w http.ResponseWriter, req *http.Request) {
    user := &amp;User{&quot;Joe&quot;,&quot;Bloggs&quot;}
    negotiator.Negotiate(w, req, user)
}
</code></pre>
<p>This in my humble opinion keeps things pretty tidy.  If you want to extend the base functionality of JSON/XML handling you can implement this interface for your own response processor:</p>
<pre><code>type ResponseProcessor interface {
	CanProcess(mediaRange string) bool
	Process(w http.ResponseWriter, model interface{})
}
</code></pre>
<p>CanProcess is called when <code>negotiator</code> loops over the media types in the Accept header.  This loop is also ordered by the weighted value in the Accept header eg. <code>Accept: application/json,application/xml;q=0.8,text/plain;q=0.5</code>, some great work by <a href="https://twitter.com/pdoh00">Phil Cleveland</a> who helped with writing <code>negotiator</code> (note: if there is no accept header or relevant response processor then <code>negotiator</code> will return a 406).  The response processor will return a boolean saying whether it can handle the current media type.  If it returns true then <code>Process</code> is called and it will then handle writing the body to the response in the format that is applicable to that response processor.</p>
<p>To add your new custom processor to <code>negotiator</code> simple pass it to the <code>New</code> method.</p>
<pre><code>func customHandler(w http.ResponseWriter, req *http.Request) {
    user := &amp;user{&quot;Joe&quot;, &quot;Bloggs&quot;}
    textplainNegotiator := negotiator.New(&amp;PlainTextResponseProcessor{})
    textplainNegotiator.Negotiate(w, req, user)
}

type PlainTextResponseProcessor struct {
}

func (*PlainTextResponseProcessor) CanProcess(mediaRange string) bool {
	return strings.EqualFold(mediaRange, &quot;text/plain&quot;)
}

func (*PlainTextResponseProcessor) Process(w http.ResponseWriter, model interface{}) {

	w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain&quot;)

	val := reflect.ValueOf(model).Elem()

	for i := 0; i &lt; val.NumField(); i++ {
        valueField := val.Field(i).String()
        typeField := val.Type().Field(i)

        w.Write([]byte(typeField.Name + &quot; : &quot; + valueField + &quot; &quot;))
	}

}
</code></pre>
<p>This is a slightly contrived example but you can see what needs to be done to add your own response processor for it to be used by <code>negotiator</code>.  One thing I don&rsquo;t like about this is that you need to call <code>New</code> in every handler however, you may only want this processor in certain route handlers in your application.  Going back to my first example, what you could do is insert the pointer returned from calling <code>New</code> and insert it into the http context and then in the handlers pull it out and then call <code>Negotiate</code>.  You can see a demo of this in the Github repo <a href="https://github.com/jchannon/negotiator/blob/master/demo/main.go">here</a></p>
<p>Hopefully other Go developers will find this library useful but I&rsquo;m happy with what I&rsquo;ve done here and its allowed me to learn more Go and interact with the community.  I&rsquo;m also pretty chuffed that its got 100% unit test coverage according to the built in golang tools.  I&rsquo;m  very impressed with the receptiveness of the Go community and the amount of libraries and blog posts out there to learn from.  I&rsquo;ve managed to pick up Go pretty easily and I&rsquo;m really loving it.  Another big thanks to <a href="https://twitter.com/pdoh00">Phil Cleveland</a>, another .Net developer trying to pick up Go, for his help with <code>negotiator</code>.</p>
<p>For more information check out the <a href="http://github.com/jchannon/negotiator">Github repository</a> and the <code>godoc</code> documentation <a href="https://godoc.org/github.com/jchannon/negotiator">here</a></p>
<p>Shout out to <a href="http://nancyfx.org">NancyFX</a>, my first love, for inspiring the design of the ResponseProcessor interface.</p>

                            
                            
                            
                            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "jonathanchannonblog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                            
                        </section>

					</div>

                    

<footer id="footer">
    
    <section class="split contact">
        
        
        
        
        <section>
            <h3>Social</h3>
            <ul class="icons alt">
                
                <li><a href="https://twitter.com/jchannon" class="icon alt fa-twitter"><span class="label">Twitter</span></a></li>
                
                
                <li><a href="https://github.com/jchannon" class="icon alt fa-github"><span class="label">GitHub</span></a></li>
                
                
                
                
                <li><a href="https://www.linkedin.com/in/jonathanchannon/" class="icon alt fa-linkedin"><span class="label">LinkedIn</span></a></li>
                
                
                
                
                
            </ul>
        </section>
        
    </section>
</footer>

                    
<div id="copyright">
    <ul><li>&copy; Blog</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li><li>Hugo Port: <a href="https://curtistimson.co.uk">curttimson</a></li></ul>
</div>


            </div>
            
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-7138405-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
            










<script src='/assets/js/bundle.js'></script>


	</body>
</html>
