<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on </title>
    <link>/tags/golang/</link>
    <description>Recent content in golang on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 16 Nov 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/golang/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introducing Negotiator  - a GoLang content negotiation library</title>
      <link>/2015-11-16-content-negotiation-golang/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/2015-11-16-content-negotiation-golang/</guid>
      <description>&lt;p&gt;In my continued experience learning GoLang I started looking at how to best use it when dealing with HTTP.  The idiomatic way to use GoLang and HTTP is to use the standard library which keeps things minimal but there are a few features missing.  The first thing is a router.  OOTB GoLang doesn&amp;rsquo;t have a router and the majority seem to suggest using a package called Mux from Gorilla Toolkit, a set of libraries that aims to improve the standard library from Go.  After having a play with it I didn&amp;rsquo;t really warm to it so spent some time looking into the alternatives (and there are plenty!) and eventually decided upon &lt;a href=&#34;https://goji.io&#34;&gt;Goji&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once I had started using Goji I then wanted to handle content negotiation in my HTTP handler.  As I said earlier GoLang is minimal in its offerings OOTB and this is a good thing.  Just for the record there are a few frameworks out there if you want/need and all encompassing framework such as Martini, Revel and Echo.  These tend to bend the idioms  of GoLang a bit and even the author of Martini blogged on this fact due to feedback from the community that although its capabilities are great they aren&amp;rsquo;t idiomatic Go.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing PoGo  - a GoLang, Twitter favourites to Pocket importer</title>
      <link>/2015-10-27-introducting-pogo-golang-twitter-pocket/</link>
      <pubDate>Tue, 27 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/2015-10-27-introducting-pogo-golang-twitter-pocket/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve always kept myself up to date with the latest languages arriving on the scene and I&amp;rsquo;ve spent time in the past learning Node and last year I learnt Python by doing the Omnisharp plugin for Sublime.  I have recently been looking for a static language that I can transfer my C# skills too and I had narrowed it down to 3; Swift, Kotlin and GoLang.  I started out with Kotlin and setting up a dev environment with IntelliJ and running the koans that Jetbrains advise you step through to pick up the language.  Whilst it seemed relatively straightforward I got &amp;ldquo;noob confused&amp;rdquo; when I saw examples of Java calling into Kotlin with get/set prefixes somehow magically added to Kotlin properties. It turns out the Kotlin compiler does this for Java libraries so it can communicate with it, to me it seemed strange that I code a library in one language and the compiler then exposes these methods and properties slightly differently. Superficial as this sounds I also didn&amp;rsquo;t really like the mammoth that appears to be IntelliJ.  Coming from a predominantly Visual Studio background but working with Omnisharp I wanted a lightweight editor with some refactoring, intellisense and error highlighting.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>