<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>owin on </title>
    <link>/tags/owin/</link>
    <description>Recent content in owin on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 27 Jun 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/owin/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Porting OWIN middleware to ASP.Net Core</title>
      <link>/2016-06-27-porting-owin-middleware-aspnetcore/</link>
      <pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>/2016-06-27-porting-owin-middleware-aspnetcore/</guid>
      <description>&lt;p&gt;In our application at work we make use of various middleware and as we are making everything run on .Net Core the time has come to port said middleware to .Net Core.  If you don&amp;rsquo;t already know ASP.Net Core has a bridge that allows you to use OWIN components in an ASP.Net Core application.  This will convert the HttpContext into a OWIN environment dictionary on input and then back again on output.&lt;/p&gt;
&lt;p&gt;Lets take an example of some middleware&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyMiddleware
{
    private readonly Func&amp;lt;IDictionary&amp;lt;string, object&amp;gt;, Task&amp;gt; nextFunc;
    private readonly OwinUserMiddlewareOptions options;

    public OwinUserMiddleware(Func&amp;lt;IDictionary&amp;lt;string, object&amp;gt;, Task&amp;gt; nextFunc, MyMiddlewareOptions options)
    {
        this.options = options;
        this.nextFunc = nextFunc;
    }

    public Task Invoke(IDictionary&amp;lt;string, object&amp;gt; environment)
    {
        //Everything is awesome
        return nextFunc(environment);
    }
}

public static class MyMiddlewareExtensions
{
    public static IAppBuilder UseMyMiddleware(this IAppBuilder app, MyMiddlewareOptions options = null)
    {
        return app.Use(typeof(MyMiddleware), options);
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Cookie Authentication &amp; CRSF with AngularJs, Owin &amp; Mono</title>
      <link>/2015-04-27-cookie-authentication-angularjs-csrf-owin-mono/</link>
      <pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/2015-04-27-cookie-authentication-angularjs-csrf-owin-mono/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m currently working on a project that has &lt;a href=&#34;http://nancyfx.org&#34;&gt;Nancy&lt;/a&gt; serving up an API.  For the UI there is AngularJS.  We were using JWT for authentication just to get us up and running but then as things became more final in the product we knew it would be better to swap to cookies for security plus we may as well leverage the browser capabilities  for cookie handling. I&amp;rsquo;m not going to get into the arguments about JWT security vs cookie security, there are advantages/disadvantages for using both in this scenario.  Our API is built on top of OWIN and Microsoft provide cookie middleware so I thought this would be nice and simple to plug in.  Lets just remember I&amp;rsquo;m working on Mono!&lt;/p&gt;
&lt;p&gt;In our Startup class I added the below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationMode = AuthenticationMode.Active,
    CookieHttpOnly = true,
    CookieSecure = Microsoft.Owin.Security.Cookies.CookieSecureOption.SameAsRequest,
    SlidingExpiration = true,
    AuthenticationType = &amp;quot;MyCookie&amp;quot;,
    CookieName = &amp;quot;MyCookie&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully thats pretty self explanatory. So I fired up my application and BOOM!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nancy, ASP.Net vNext, VS2014 &amp; Azure</title>
      <link>/2014-06-14-nancy-aspnet-vnext-vs2014-azure/</link>
      <pubDate>Sat, 14 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/2014-06-14-nancy-aspnet-vnext-vs2014-azure/</guid>
      <description>&lt;p&gt;By now we know of Microsoft&amp;rsquo;s plans for the next version of ASP.Net and they&amp;rsquo;ve turned it on its head and from the looks of it, its goooooood!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.hanselman.com/blog/IntroducingASPNETVNext.aspx&#34;&gt;Here&lt;/a&gt; is a blog post from Scott Hanselman introducing ASP.Net vNext. There are introductory and deep dive videos available for your perusal which are also well worth a watch.&lt;/p&gt;
&lt;p&gt;The TL;DR is ASP.Net vNext will take heavy influence from Node.js by using Owin to wire up all the app dependencies and middleware.  It will also remove *.csproj files and use a project.json file similar to Node&amp;rsquo;s package.json and use NuGet to reference the application&amp;rsquo;s dependencies.  It also takes inspiration from Node and Nancy&amp;rsquo;s approach requiring you to opt-in to dependencies rather that traditionally having everything but the kitchen sink.  It also takes influence from Nancy via built in dependency injection and Mono support.  Microsoft announced they will run all their vNext tests against Mono builds ensuring all their code is compatible for cross platform deployments.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s a tweet direct from the horses mouth albeit with a typo .&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/XMmMDce.png&#34; alt=&#34;vNext influenced by Node/Nancy&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing Owin.StatelessAuth with Nancy/Angular demo</title>
      <link>/2014-05-07-introducing-owin-statelessauth-with-nancy-angular-demo/</link>
      <pubDate>Wed, 07 May 2014 00:00:00 +0000</pubDate>
      
      <guid>/2014-05-07-introducing-owin-statelessauth-with-nancy-angular-demo/</guid>
      <description>&lt;p&gt;If you&amp;rsquo;re writing an API, current thinking is to provide a token in the &lt;code&gt;Authorization&lt;/code&gt; header for your app to validate when the request comes in.  I have used the &lt;a href=&#34;http://www.nuget.org/packages/Nancy.Authentication.Stateless/&#34;&gt;Nancy.Authentication.Stateless&lt;/a&gt; package in the past for my APIs and even have a demo of it &lt;a href=&#34;https://github.com/jchannon/Nancy.Demo.StatelessAuth&#34;&gt;here&lt;/a&gt; if you&amp;rsquo;re interested (there are more Nancy demos at &lt;a href=&#34;http://samples.nancyfx.org/&#34;&gt;http://samples.nancyfx.org&lt;/a&gt;). This is a great package and does a great job but what if one day you want to use &lt;a href=&#34;http://www.asp.net/signalr&#34;&gt;SignalR&lt;/a&gt; v2 that uses &lt;a href=&#34;http://owin.org/&#34;&gt;OWIN&lt;/a&gt; and you want to validate not just requests to your Nancy app but also the SignalR requests?  You&amp;rsquo;re going to need to validate requests as they come in before they get to SignalR or Nancy.&lt;/p&gt;
&lt;p&gt;For those of you who are not quite up to date or unsure what OWIN is let me try and give you the tl:dr, no doubt others may say its something slightly different.  Imagine you are asked to create a ASP.Net MVC 3 app (ignore the fact that that person needs a slap) so you fire up Visual Studio and create the app.  So what has it done? Its created an app that runs on IIS and all requests come straight into your app.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>